

## 字典文件内容编写规则

渲染规则部分主要参考weakfilescan, 另外修复Python3环境的一些错误, 并分离了因变量和基本变量的替换。

weakfilescan原版请访问 https://github.com/ring04h/weakfilescan



### 1、字典规则渲染顺序

```
1. 对每行字典的动态规则({*****}$)进行解析，每行仅且支持一句解析规则。
2. 对%基本变量%进行替换，每行字典支持多个不同的基本变量。
3. 对%%因变量%%进行替换，每行字典支持多个不同的因变量。
```



### 2、字典规则编写限制

```
1、字典内的每一行规则最多存在 【1个】解析规则

2、字典内的每一行规则支持多个【%基本变量%】、【%%因变量%%】
```



### 3、基础变量概念

    字典内以 【%变量名%】 格式调用, 
    
    变量名是从base目录下的字典的文件名中动态获取。
    
    基础变量会在【基本变量替换时】被替换为【字典文件的内容】。
    
    基本变量替换字典示例： 
    backup_ext.lst 字典文件
    衍生规则: {'%backup_ext%': ['rar','zip']}



### 4、因变量概念

    字典内以【%%变量名%%】格式调用
    
    因变量在代码中定义,因变量对应的内容获取函数也在代码中定义。
    
    因变量会在【因变量替换时】被替换为从URL中动态获取的内容。
    
    目前内置有【%%DOMAIN%%、%%PATH%%】两个变量,
    %%DOMAIN%%   域名单词相关的列表-自动获取
    %%PATH%%     路径单词相关的列表-自动获取
    %%FILE_NAME%%  路径文件名因变量-有后缀-自动获取
    %%PURE_NAME%% 路径文件名因变量-无后缀-自动获取
    %%BLANK%% 替换为空字符-固定为['']
    %%DEPENDENT%% 的自定义因变量，默认为[]
    
    
    因变量替换字典示例:
    解析 https://www.baidu.com 得到因变量字典: {'%%DOMAIN%%': ['baidu','baidu_com','www.baidu.com','baidu.com','www_baidu_com']}



### 5、动态替换规则:

    动态替换规则指字典内以【{*****}$】格式调用。
    
    替换规则有【date、int、str、re】四种规则分类,每种规则可能存在多种规则类型。
    
    不同的规则的【实际解析部分】有不同的编写格式要求。

| 规则      |    说明 |
| :-------- |:--------|
| re   | 正则引擎 |
| int  | 整数 |
| str  | 字符 |
| date | 日期 |



#### 1、date类型替换规则:

    {date=日期类型:日期开始-日期结束}$
    
    规则类型:year(年) 2005-2015
    规则示例:
    {date=year:2017-2018}$
    ['2017', '17', '2018', '18']
    
    规则类型:mon(月) 1-12
    规则示例:
    {date=mon:9-10}$
    ['9', '09', '10']
    
    规则类型:day(日) 0-30 
    规则示例:
    {date=day:9-10}$
    ['9', '09', '10']
    
    规则类型:year_mon(年月) 200501-201512
    规则示例: 
    {date=year_mon:201709-201712}$
    ['201709', '20179', '201710', '201711', '201712']
    
    规则类型:mon_day(月日) 0101-1231
    规则示例: 
    {date=mon_day:0928-1003}$
    ['0930', '1001', '0929', '09-29', '1003', '10-01', '09-30', '10-02', '10-03', '1002']
    
    规则类型:year_mon_day(年月日) 20050101-20151231
    规则示例:
    {date=year_mon_day:20170111-20170112}$
    ['170112', '20170112', '17-01-12', '2017-01-12']
    
    规则类型:mon_day_year(月日年) 01012005-12312015
    规则示例:
    {date=mon_day_year:01112017-01122017}$
    ['2017-01-12', '17-01-12', '170112', '20170112'
    
    PS：日期会出现的子分类情况，初始位数补充0911,911
    
    
    扩展：通配符支持:
    星号(*) 用于 表示当前格式的时间。
    
    示例:
    {date=day:*-*}$ 等价 {date=day:30-30}$ 
    结果 [30]
    
    {date=mon:*-*}$ 等价 {date=mon:6-6}$ 
    结果 [6, 06]
    
    {date=year:*-*}$ 等价 {date=year:2023-2023}$ 
    结果 [2023,23]
    
    {date=year_mon_day:-*}$ 等价 {date=year_mon_day:20230630-20230630}$ 
    结果 [20230630, 230630]
    
    
    扩展：时间加减计算支持：
    可以通过 -- ++ 符号对时间进行计算，可和通配符一起使用
    --基于输入的时间做减法 
    ++基于输入的时间做加法
    
    {date=day:20--10}$ 表示 20日-10天 
    等价 {date=day:10-20}$
    
    {date=mon:12-10}$ 表示 12月-10月 
    等价 {date=mon:2-10}$
    
    {date=year:*-10}$ 表示 当前年份2023-10年 
    等价 {date=year:2013-2023}$
    
    {date=year_mon_day:20230630-15}$ 
    表示 20230630-15天 
    等价 {date=year_mon_day:20230615-20230630}$
    





#### 2、int类型替换规则:

    {int=数字类型#元素长度$步长:数字开始-数字结束}$
       
    规则类型:series(正常按照顺序递进,支持$步长选项)
    规则示例:
    {int=series:1-5}$
    ['1', '2', '3', '4', '5']
    
    {int=series$2:1-15}$ #使用步长选项
    ['1', '3', '5', '7', '9', '11', '13', '15']
    
    规则提示:
    仅series类型支持步长
    仅series类型长度选项没有实际用处
    
    规则类型:digits(连号数字)
    规则示例:
    {int=digits#3:1-5}$
    ['123', '321', '234', '432', '345', '543']
    规则提示:#3表示数字的长度为3
    
    规则类型:overlap(重叠数字)
    规则示例:
    {int=overlap#3:1-9}$
    ['111', '222', '333', ..., '777', '888', '999']
    
    {int=overlap#3:11-22}$
    ['111111', '121212', ..., '202020', '212121', '222222']
    规则提示:#3表示元素的个数为3



#### 3、str类型替换规则:

    {str=字符类型#元素长度:字符开始-字符结束}$
        
    规则类型:letters(按照顺序递进)
    规则示例:
    {str=letters#3:a-d}$
    ['abc', 'bcd']
    规则提示:#3表示字母的长度为3
    
    规则类型:overlap(重叠字母)
    规则示例:
    {str=overlap#3:A-D}$
    ['AAA', 'BBB', 'CCC', 'DDD']
    规则提示:#3表示元素的个数为3



#### 4、re类型替换规则:

    re是正则解析器,会根据正则生成符合正则规则的字符串,是最常用的规则。
    
    已知的正则解析生成器有 exrex、sre_yield,解析结果是相同的,只不过有不同的解析算法。
    
    {re=引擎类型:正则表达式}$
    
    引擎类型:exrex(exrex正则解析引擎)
    {re=exrex:(201[7-9]{1}[1]{1}[8-9]{1})}$ 
    ['201718', '201719', '201818', '201819', '201918', '201919']



### 6、字典规则调试和验证

 1、如果动态解析规则存在问题,会显示错误提示,并忽略解析该条规则。

```
规则报错示例:
​    [22:30:20] [-] 每条字典规则仅支持单个{xx=xx:xxxx}$格式规则!!! 
​    Rule: /{date=year:2021-2022}$-{re=exrex:([ABC])(%backup_ext%)}$ 
​    Error: too many values to unpack (expected 2)
​    错误原因:
​    本规则内带有了两条解析规则,所以导致了错误。
```



### 7、其他字典规则

```
1、支持###号注释,对###号开头的行,和频率字符串后面的###号都会进行删除

注：可能影响到目录中的###号
```



### 8、规则示例参考

```
RuleParser('/{re=exrex:(||v[1-3]|v[1-3]\.[0-5]|api|api/v[1-3]|api/v[1-3]\.[0-5])}$/').parse() 

['//', '//', '/v1/', '/v2/', '/v3/', '/v1.0/', '/v1.1/', '/v1.2/',..., '/api/', '/api/v1/', '/api/v2/', '/api/v3/', '/api/v1.0/', '/api/v1.1/', '/api/v1.2/', ....]


RuleParser('/{re=exrex:(|v[1-3]|v1\.[0-9]|v[2-3]\.[0-5]|api|api/v[1-3]|api/v1\.[0-9]|api/v[2-3]\.[0-5])}$/').parse() 
['//', '/v1/', '/v2/', '/v3/', '/v1.0/', '/v1.1/', '/v1.2/',..., '/api/', '/api/v1/', '/api/v2/', '/api/v3/', '/api/v1.0/', '/api/v1.1/', '/api/v1.2/', ...]


RuleParser('{date=year:2017-2018}$').parse() 
['2017', '17', '2018', '18']

RuleParser('{date=mon:9-10}$').parse() 
['9', '09', '10']

RuleParser('{date=day:12-15}$').parse() 
['12', '13', '14', '15']

RuleParser('{date=day:9-10}$').parse() 
['9', '09', '10']

RuleParser('{date=year_mon:201709-201712}$').parse() 
['201709', '20179', '201710', '201711', '201712']

RuleParser('{date=mon_day:0928-1003}$').parse()
['0930', '1001', '0929', '09-29', '1003', '10-01', '09-30', '10-02', '10-03', '1002']

RuleParser('{date=year_mon_day:20170111-20170112}$').parse()  
['170112', '20170112', '17-01-12', '2017-01-12']

RuleParser('{date=mon_day_year:01112017-01122017}$').parse()
['2017-01-12', '17-01-12', '170112', '20170112']

RuleParser('{int=series:1-5}$').parse() 
['1', '2', '3', '4', '5']

RuleParser('{int=series$2:1-15}$').parse()  
['1', '3', '5', '7', '9', '11', '13', '15']

RuleParser('{int=digits#3:1-5}$').parse() 
['123', '321', '234', '432', '345', '543']

RuleParser('{int=overlap#3:1-9}$').parse() 
['111', '222', '333', '444', '555', '666', '777', '888', '999']

RuleParser('{int=overlap#3:11-22}$').parse() 
['111111', '121212', '131313', '141414', '151515', '161616', '171717', '181818', '191919', '202020', '212121', '222222']

RuleParser('{str=letters#3:a-d}$').parse() 
['abc', 'bcd']

RuleParser('{str=overlap#3:A-D}$').parse()
['AAA', 'BBB', 'CCC', 'DDD']

RuleParser('{re=exrex:(201[7-9]{1}[1]{1}[8-9]{1})}$').parse() 
['201718', '201719', '201818', '201819', '201918', '201919']

RuleParser('{re=sre_yield:(201[7-9]{1}[1]{1}[8-9]{1})}$').parse()
['201718', '201818', '201918', '201719', '201819', '201919']
```

